---
title: Reactivity
---

```{r setup, include = FALSE}
# Load shiny
library(shiny)
# Load tidyverse
library(tidyverse)
# Set option to launch shiny app in viewer
if (requireNamespace('rstudioapi', quietly = TRUE)){
  options(shiny.launch.browser = rstudioapi::viewer)
}
# Load babynames
library(babynames)
```

## Input -> Output

![hello-world-app](img/hello-world.gif)


```{r}
ui <- fluidPage(
  # 0. Display a title panel
  titlePanel('Hello World App'),
  # 1. Display a text input to get user name
  textInput('name', label = 'Enter your name'),
  # 2. Display a text output with greeting
  textOutput('greeting')
)
server <- function(input, output, session){
  # 3. Render a text greeting
  output$greeting <- renderText({
    paste("Hello,", "World")
  })
}
shinyApp(ui, server)
```

## Input -> Output

```{r}
ui <- fluidPage(
  # Display a title panel with the name of the app
  titlePanel("Baby Names Explorer"),
  # Display a text input to get user name
  textInput('name', 'Enter Name'),
  # Display a plot output of the trends
  plotOutput('plot')
)

server <- function(input, output, session) {
  # Render a plot showing trend in name across years
  output$plot <- renderPlot({
    babynames %>% 
      filter(name == !!input$name) %>% 
      ggplot(aes(x = year, y = n, color = sex)) +
      geom_line()
  })
}

shinyApp(ui, server)
```

## Input -> Outputs

<!--
What if we want to add a table of ...
-->

```{r}
ui <- fluidPage(
  # Display a title panel with the name of the app
  titlePanel("Baby Names Explorer"),
  # Display a text input to get user name
  textInput('name', 'Enter Name'),
  # Display a plot output of the trends
  plotOutput('plot'),
  # Display an interactive table output of the trends
  dataTableOutput('table')
)

server <- function(input, output, session) {
  # Render a plot showing trend in name across years
  output$plot <- renderPlot({
    babynames %>% 
      filter(name == !!input$name) %>% 
      ggplot(aes(x = year, y = n, color = sex)) +
      geom_line()
  })
  # Render an interactive table showing trend in name across years
  output$table <- renderDataTable({
    babynames %>% 
      filter(name == !!input$name)
  })
}

shinyApp(ui, server)
```

## Reactive Expressions

Reactive expressions allow encapsulation of repeated computations leading 
to better performance. A reactive expression can depend on inputs as well
as other reactive expressions, and updates its value in response to its
dependencies. There are two significant advantages of using reactive
expressions:

1. They are executed lazily. For example, if we have a shiny app with 
   different tabs, then only those reactive expressions that are called by
   an output on the visible tab get executed.
2. They are cached. Hence, expensive computations only get executed once,
   providing a significant 


```{r}
ui <- fluidPage(
  titlePanel("Baby Names Explorer"),
  textInput('name', 'Enter Name'),
  plotOutput('plot'),
  DT::DTOutput('table')
)

server <- function(input, output, session) {
  rval_names <- reactive({
    babynames %>% 
      filter(name == !!input$name)
  })
  output$plot <- renderPlot({
     rval_names() %>% 
      ggplot(aes(x = year, y = n, color = sex)) +
      geom_line()
  })
  output$table <- DT::renderDT({
    rval_names()
  })
}

shinyApp(ui, server)
```

## Delay Actions

So far you have seen how reactivity can automatically trigger changes in
outputs based on changes to inputs. Sometimes, it is desirable to delay
actions. For example, we might want to click on an update button in order
to update the outputs.


```{r}
ui <- fluidPage(
  titlePanel("Baby Names Explorer"),
  textInput('name', 'Enter Name'),
  # Display an action button to update the app
  actionButton('update', 'Update'),
  plotOutput('plot'),
  DT::DTOutput('table')
)

server <- function(input, output, session) {
  # Use an eventReactive to delay execution until user clicks on update.
  rval_names <- eventReactive(input$update, {
    babynames %>% 
      filter(name == !!input$name)
  })
  output$plot <- renderPlot({
     rval_names() %>% 
      ggplot(aes(x = year, y = n, color = sex)) +
      geom_line()
  })
  output$table <- DT::renderDT({
    rval_names()
  })
}

shinyApp(ui, server)
```

## Trigger Actions

At times, we might want to manually trigger an action in response to an
event. This should be very familiar to those of you who have used javascript frameworks like `jQuery`. We can achieve manual callbacks in 
shiny using `observeEvent`

```{r}
ui <- fluidPage(
  titlePanel("Baby Names Explorer"),
  textInput('name', 'Enter Name'),
  actionButton('update_output', 'Update'),
  # Display a button to show an 'About' this app
  actionButton('show_about', 'About'),
  plotOutput('plot'),
  DT::DTOutput('table')
)

server <- function(input, output, session) {
  rval_names <- eventReactive(input$update_output, {
    babynames %>% 
      filter(name == !!input$name)
  })
  output$plot <- renderPlot({
     rval_names() %>% 
      ggplot(aes(x = year, y = n, color = sex)) +
      geom_line()
  })
  output$table <- DT::renderDT({
    rval_names()
  })
  # Display a modal dialog when user clicks on the 'About' button
  observeEvent(input$show_about, {
    showModal(modalDialog("This app was built by Ramnath"))
  })
}

shinyApp(ui, server)
```

